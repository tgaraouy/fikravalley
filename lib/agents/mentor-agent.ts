/**
 * MENTOR AGENT - Expert Matcher
 * 
 * Locke: "The company you keep determines the knowledge you gain."
 * 
 * Finding the RIGHT mentor = finding someone who has INTIMATE knowledge of your space.
 * Not just "knows OF" your sector, but has LIVED it.
 * 
 * Core Principle:
 * - Match based on domain expertise + lived experience
 * - Generate warm introductions (not cold)
 * - Track mentor effectiveness
 * - Build trust through transparency
 */

// ==================== INTERFACES ====================

export interface Mentor {
  id: string;
  name: string;
  avatar: string;
  title: string;
  company: string;
  
  expertise: string[]; // ['healthtech', 'RFID', 'hospital_ops']
  sectors: string[]; // ['healthcare', 'technology']
  techStack: string[]; // ['React', 'Node.js', 'IoT']
  locations: string[]; // ['Rabat', 'Casablanca']
  
  moroccoPriorities: string[]; // ['digital_morocco', 'healthcare']
  
  // Experience proof (Locke: they must KNOW, not just "know of")
  livedExperience: {
    founded: string[]; // Companies founded
    worked: string[]; // Places worked
    projects: string[]; // Specific projects
    yearsExperience: number;
  };
  
  // Availability
  availableSlots: number; // Slots available this month
  responseRate: number; // 0-1 (how often responds)
  avgResponseTime: string; // "2 hours"
  
  // Track record
  mentoredIdeas: number; // How many ideas mentored
  successRate: number; // 0-1 (how many got funded)
  testimonials: Testimonial[];
  
  // Locke metric
  intimacyRating: number; // 0-10 (how deeply do they know their domain?)
}

export interface Testimonial {
  from: string;
  text: string;
  ideaTitle: string;
  funded: boolean;
}

export interface MentorMatch {
  mentor: Mentor;
  matchScore: number; // 0-100
  
  reasons: string[]; // Why this match is good
  
  alignment: {
    expertiseMatch: number; // 0-1
    sectorMatch: number;
    locationMatch: number;
    priorityMatch: number;
    intimacyMatch: number; // Do they have intimate knowledge?
  };
  
  availability: {
    available: boolean;
    nextSlot?: Date;
    responseExpected: string; // "within 24 hours"
  };
  
  confidence: 'low' | 'medium' | 'high' | 'perfect';
}

export interface IntroductionMessage {
  subject: string;
  body: string; // Generated by Claude
  tone: 'formal' | 'casual' | 'darija_mix';
  
  suggestedAsk: string; // What to ask for (30-min call, deck review, etc.)
  
  // Locke wisdom
  intimacyNote: string; // "This mentor has LIVED this problem in..."
}

export interface User {
  name: string;
  email: string;
  bio?: string;
}

export interface IdeaStatement {
  title: string;
  problem: {
    sector: string;
    location: string;
    description?: string;
  };
  operations?: {
    technology?: string[];
  };
  qualification?: string;
  alignment?: {
    moroccoPriorities?: string[];
  };
}

interface ClaudeAPI {
  complete(params: any): Promise<any>;
}

interface VectorDatabase {
  semanticSearch(collection: string, params: any): Promise<Mentor[]>;
}

// ==================== MAIN CLASS ====================

export class MentorAgent {
  private claudeAPI?: ClaudeAPI;
  private vectorDB?: VectorDatabase;
  
  // Mock mentor database for testing (replace with real DB in production)
  private mockMentors: Mentor[] = [];
  
  constructor(claudeAPI?: ClaudeAPI, vectorDB?: VectorDatabase) {
    this.claudeAPI = claudeAPI;
    this.vectorDB = vectorDB;
    this.initializeMockMentors();
  }

  // ==================== FIND BEST MENTORS ====================

  /**
   * Find best matching mentors for an idea
   */
  async findMentors(idea: IdeaStatement, limit: number = 5): Promise<MentorMatch[]> {
    // 1. Extract key attributes from idea
    const attributes = {
      sector: idea.problem.sector, // 'healthcare'
      techStack: idea.operations?.technology || [], // ['RFID', 'React']
      location: idea.problem.location, // 'Rabat'
      stage: idea.qualification, // 'qualified'
      priorities: idea.alignment?.moroccoPriorities || []
    };
    
    // 2. Query mentor database
    let candidates: Mentor[];
    
    if (this.vectorDB) {
      // Use vector database for semantic search
      candidates = await this.vectorDB.semanticSearch('mentors', {
        query: `${attributes.sector} ${attributes.techStack.join(' ')} ${attributes.location}`,
        filters: {
          availableSlots: { gt: 0 },
          intimacyRating: { gte: 6 }
        },
        limit: limit * 2
      });
    } else {
      // Use mock database for testing
      candidates = this.mockMentors.filter(m => 
        m.availableSlots > 0 && m.intimacyRating >= 6
      );
    }
    
    // 3. Score each mentor
    const scored: MentorMatch[] = candidates.map(mentor => {
      const matchScore = this.calculateMatchScore(mentor, attributes);
      const alignment = this.calculateAlignment(mentor, attributes);
      
      return {
        mentor,
        matchScore,
        reasons: this.explainMatch(mentor, attributes),
        alignment,
        availability: {
          available: mentor.availableSlots > 0,
          responseExpected: mentor.avgResponseTime
        },
        confidence: this.determineConfidence(matchScore)
      };
    });
    
    // 4. Sort by match score and return top N
    return scored
      .sort((a, b) => b.matchScore - a.matchScore)
      .slice(0, limit);
  }

  // ==================== CALCULATE MATCH SCORE ====================

  /**
   * Calculate match score (0-100)
   */
  private calculateMatchScore(mentor: Mentor, attributes: any): number {
    let score = 0;
    
    // Expertise match (40 points)
    const expertiseOverlap = this.calculateOverlap(
      mentor.expertise,
      [attributes.sector, ...attributes.techStack]
    );
    score += expertiseOverlap * 40;
    
    // Location match (20 points)
    if (mentor.locations.includes(attributes.location)) {
      score += 20;
    } else if (mentor.locations.some(loc => this.isSameRegion(loc, attributes.location))) {
      score += 10; // Same region but not exact city
    }
    
    // Priority alignment (20 points)
    const priorityOverlap = this.calculateOverlap(
      mentor.moroccoPriorities,
      attributes.priorities
    );
    score += priorityOverlap * 20;
    
    // Intimacy bonus (10 points) - Locke's metric!
    if (mentor.intimacyRating >= 8) {
      score += 10;
    } else if (mentor.intimacyRating >= 6) {
      score += 5;
    }
    
    // Track record bonus (10 points)
    if (mentor.successRate >= 0.5) {
      score += 10;
    } else if (mentor.successRate >= 0.3) {
      score += 5;
    }
    
    return Math.round(score);
  }

  /**
   * Calculate detailed alignment metrics
   */
  private calculateAlignment(mentor: Mentor, attributes: any): MentorMatch['alignment'] {
    return {
      expertiseMatch: this.calculateOverlap(
        mentor.expertise,
        [attributes.sector, ...attributes.techStack]
      ),
      sectorMatch: mentor.sectors.includes(attributes.sector) ? 1.0 : 0.0,
      locationMatch: mentor.locations.includes(attributes.location) ? 1.0 : 
                     mentor.locations.some(loc => this.isSameRegion(loc, attributes.location)) ? 0.5 : 0.0,
      priorityMatch: this.calculateOverlap(
        mentor.moroccoPriorities,
        attributes.priorities
      ),
      intimacyMatch: mentor.intimacyRating / 10
    };
  }

  // ==================== EXPLAIN MATCH ====================

  /**
   * Generate human-readable reasons for the match
   */
  private explainMatch(mentor: Mentor, attributes: any): string[] {
    const reasons: string[] = [];
    
    // Expertise reasons
    const sharedExpertise = mentor.expertise.filter(e => 
      attributes.techStack.includes(e) || e === attributes.sector
    );
    
    if (sharedExpertise.length > 0) {
      reasons.push(`Expert en: ${sharedExpertise.join(', ')}`);
    }
    
    // Experience reasons (Locke: lived experience!)
    if (mentor.livedExperience.founded.length > 0) {
      reasons.push(`A fond√©: ${mentor.livedExperience.founded[0]}`);
    }
    
    if (mentor.livedExperience.projects.length > 0) {
      const relevantProject = mentor.livedExperience.projects.find(p => 
        p.toLowerCase().includes(attributes.sector.toLowerCase())
      );
      if (relevantProject) {
        reasons.push(`A travaill√© sur: ${relevantProject}`);
      }
    }
    
    // Location reason
    if (mentor.locations.includes(attributes.location)) {
      reasons.push(`Bas√© √† ${attributes.location} (comme vous)`);
    }
    
    // Track record
    if (mentor.successRate >= 0.5) {
      reasons.push(`${Math.round(mentor.successRate * 100)}% de ses mentor√©s ont √©t√© financ√©s`);
    }
    
    // Intimacy reason (Locke!)
    if (mentor.intimacyRating >= 8) {
      reasons.push(`‚≠ê Connaissance INTIME du domaine (${mentor.intimacyRating}/10 - Locke's standard)`);
    }
    
    return reasons;
  }

  // ==================== GENERATE WARM INTRODUCTION ====================

  /**
   * Generate personalized introduction message
   */
  async generateIntroduction(
    idea: IdeaStatement,
    mentor: Mentor,
    creator: User
  ): Promise<IntroductionMessage> {
    // Find specific connection points
    const connectionPoints = this.findConnectionPoints(idea, mentor);
    
    // If Claude API is available, use it
    if (this.claudeAPI) {
      return this.generateIntroductionWithClaude(idea, mentor, creator, connectionPoints);
    }
    
    // Otherwise, use template-based generation
    return this.generateIntroductionTemplate(idea, mentor, creator, connectionPoints);
  }

  /**
   * Generate introduction with Claude API
   */
  private async generateIntroductionWithClaude(
    idea: IdeaStatement,
    mentor: Mentor,
    creator: User,
    connectionPoints: string[]
  ): Promise<IntroductionMessage> {
    const prompt = `You are helping ${creator.name} write a warm introduction email to ${mentor.name}, a mentor on Fikra Valley.

CONTEXT:
- Idea: ${idea.title}
- Sector: ${idea.problem.sector}
- Creator background: ${creator.bio || 'Not provided'}
- Mentor expertise: ${mentor.expertise.join(', ')}
- Mentor experience: ${mentor.livedExperience.founded.join(', ')}

CONNECTION POINTS:
${connectionPoints.map(cp => `- ${cp}`).join('\n')}

LOCKE'S INSIGHT:
The mentor has LIVED EXPERIENCE in ${connectionPoints[0]}. 
The creator should acknowledge this INTIMATE knowledge and express desire to learn.

INSTRUCTIONS:
1. Write subject line (short, specific)
2. Write email body (150-200 words)
3. Tone: Professional but warm, can mix Darija if appropriate
4. Structure:
   - Brief intro of who you are
   - Specific reason for reaching out (mention connection points!)
   - Acknowledge mentor's lived experience (Locke: they KNOW, not just "know of")
   - Specific ask (30-min call? deck review?)
   - Gratitude
5. End with clear call-to-action

OUTPUT FORMAT:
{
  "subject": "...",
  "body": "...",
  "tone": "casual",
  "suggestedAsk": "..."
}`;

    const response = await this.claudeAPI!.complete({
      prompt,
      model: 'claude-sonnet-4-20250514',
      max_tokens: 500
    });
    
    const generated = JSON.parse(response.content[0].text);
    const intimacyNote = this.generateIntimacyNote(mentor, idea);
    
    return {
      ...generated,
      intimacyNote
    };
  }

  /**
   * Generate introduction using template
   */
  private generateIntroductionTemplate(
    idea: IdeaStatement,
    mentor: Mentor,
    creator: User,
    connectionPoints: string[]
  ): IntroductionMessage {
    const subject = `Demande de mentorat - ${idea.title}`;
    
    const body = `Bonjour ${mentor.name},

Je m'appelle ${creator.name} et je travaille sur "${idea.title}" dans le secteur ${idea.problem.sector}.

${connectionPoints.length > 0 ? `J'ai remarqu√© que ${connectionPoints[0].toLowerCase()}, ce qui me fait penser que vous avez une compr√©hension INTIME des d√©fis que je rencontre.` : ''}

${mentor.livedExperience.founded.length > 0 ? `Votre exp√©rience en tant que fondateur de ${mentor.livedExperience.founded[0]} est particuli√®rement inspirante. ` : ''}Ce n'est pas juste quelqu'un qui "conna√Æt DE" ${idea.problem.sector} que je cherche, mais quelqu'un qui l'a V√âCU - et c'est clairement votre cas.

Seriez-vous disponible pour un appel de 30 minutes? J'aimerais vous pr√©senter mon projet et b√©n√©ficier de vos conseils bas√©s sur votre exp√©rience r√©elle.

Merci d'avance pour votre temps.

Cordialement,
${creator.name}`;

    const intimacyNote = this.generateIntimacyNote(mentor, idea);
    
    return {
      subject,
      body,
      tone: 'casual',
      suggestedAsk: 'Appel de 30 minutes pour pr√©senter le projet et obtenir des conseils',
      intimacyNote
    };
  }

  // ==================== GENERATE INTIMACY NOTE ====================

  /**
   * Generate Locke-inspired note about mentor's intimate knowledge
   */
  private generateIntimacyNote(mentor: Mentor, idea: IdeaStatement): string {
    if (mentor.livedExperience.founded.length > 0) {
      return `üí° Locke's Insight:

${mentor.name} a FOND√â ${mentor.livedExperience.founded[0]}.

Ce n'est pas quelqu'un qui "conna√Æt DE" ${idea.problem.sector}.
C'est quelqu'un qui l'a V√âCU.

Cette personne a l'INTIMIT√â avec les d√©fis que vous allez rencontrer.

√âcoutez attentivement. Leurs insights viennent de l'exp√©rience r√©elle.`;
    }
    
    if (mentor.livedExperience.projects.length > 0) {
      return `üí° Locke's Insight:

${mentor.name} a travaill√© sur des projets similaires au v√¥tre.

${mentor.intimacyRating}/10 d'intimit√© avec le domaine.

Cette personne a fait les erreurs, trouv√© les solutions.
Apprenez de leur v√©cu, pas juste de leur th√©orie.`;
    }
    
    return `üí° Locke's Insight:

${mentor.name} a ${mentor.livedExperience.yearsExperience} ans d'exp√©rience dans le domaine.

Cette connaissance vient de l'ACTION, pas des livres.
√âcoutez avec attention. Posez des questions sur leur V√âCU.`;
  }

  // ==================== HELPER METHODS ====================

  /**
   * Find specific connection points between idea and mentor
   */
  private findConnectionPoints(idea: IdeaStatement, mentor: Mentor): string[] {
    const points: string[] = [];
    
    // Shared sector
    if (mentor.expertise.includes(idea.problem.sector)) {
      points.push(`Vous travaillez tous deux dans ${idea.problem.sector}`);
    }
    
    // Shared tech
    const sharedTech = (idea.operations?.technology || []).filter(t => 
      mentor.techStack.includes(t)
    );
    if (sharedTech.length > 0) {
      points.push(`Expertise commune: ${sharedTech.join(', ')}`);
    }
    
    // Shared location
    if (mentor.locations.includes(idea.problem.location)) {
      points.push(`Vous √™tes tous deux √† ${idea.problem.location}`);
    }
    
    // Similar past projects
    if (mentor.livedExperience.projects.length > 0) {
      points.push(`${mentor.name} a travaill√© sur des projets similaires`);
    }
    
    return points;
  }

  /**
   * Calculate overlap between two arrays (0-1)
   */
  private calculateOverlap(arr1: string[], arr2: string[]): number {
    if (arr1.length === 0 || arr2.length === 0) return 0;
    
    const overlap = arr1.filter(item => arr2.includes(item)).length;
    return overlap / Math.min(arr1.length, arr2.length);
  }

  /**
   * Check if two locations are in the same region
   */
  private isSameRegion(loc1: string, loc2: string): boolean {
    const regions: { [key: string]: string[] } = {
      'Rabat-Sal√©-K√©nitra': ['Rabat', 'Sal√©', 'K√©nitra', 'T√©mara'],
      'Casablanca-Settat': ['Casablanca', 'Settat', 'Mohammedia', 'Berrechid'],
      'F√®s-Mekn√®s': ['F√®s', 'Mekn√®s', 'Ifrane', 'Sefrou'],
      'Marrakech-Safi': ['Marrakech', 'Safi', 'Essaouira'],
      'Tanger-T√©touan-Al Hoce√Øma': ['Tanger', 'T√©touan', 'Al Hoce√Øma']
    };
    
    for (const region in regions) {
      const cities = regions[region];
      if (cities.includes(loc1) && cities.includes(loc2)) {
        return true;
      }
    }
    
    return false;
  }

  /**
   * Determine confidence level based on match score
   */
  private determineConfidence(score: number): MentorMatch['confidence'] {
    if (score >= 90) return 'perfect';
    if (score >= 70) return 'high';
    if (score >= 50) return 'medium';
    return 'low';
  }

  // ==================== MOCK DATA (FOR TESTING) ====================

  /**
   * Initialize mock mentors for testing
   */
  private initializeMockMentors() {
    this.mockMentors = [
      {
        id: 'mentor-1',
        name: 'Youssef Alami',
        avatar: '/avatars/youssef.jpg',
        title: 'CEO & Founder',
        company: 'HealthTech Maroc',
        expertise: ['healthtech', 'hospital_ops', 'RFID', 'IoT'],
        sectors: ['healthcare', 'technology'],
        techStack: ['React', 'Node.js', 'IoT', 'RFID'],
        locations: ['Rabat', 'Casablanca'],
        moroccoPriorities: ['digital_morocco', 'healthcare'],
        livedExperience: {
          founded: ['HealthTech Maroc', 'MediTrack'],
          worked: ['CHU Ibn Sina', 'Clinique Al Madina'],
          projects: ['RFID tracking system for CHU Rabat', 'Digital patient records for 5 hospitals'],
          yearsExperience: 12
        },
        availableSlots: 3,
        responseRate: 0.95,
        avgResponseTime: '2 hours',
        mentoredIdeas: 25,
        successRate: 0.64,
        testimonials: [],
        intimacyRating: 9
      },
      {
        id: 'mentor-2',
        name: 'Fatima Zahrae',
        avatar: '/avatars/fatima.jpg',
        title: 'CTO',
        company: 'EdTech Solutions',
        expertise: ['edtech', 'mobile_dev', 'gamification'],
        sectors: ['education', 'technology'],
        techStack: ['React Native', 'Flutter', 'Firebase'],
        locations: ['Casablanca', 'Marrakech'],
        moroccoPriorities: ['digital_morocco', 'education'],
        livedExperience: {
          founded: ['EdTech Solutions'],
          worked: ['Ministry of Education', 'OCP Foundation'],
          projects: ['Mobile learning app for rural schools', 'Gamified Darija learning platform'],
          yearsExperience: 8
        },
        availableSlots: 2,
        responseRate: 0.88,
        avgResponseTime: '4 hours',
        mentoredIdeas: 18,
        successRate: 0.56,
        testimonials: [],
        intimacyRating: 8
      },
      {
        id: 'mentor-3',
        name: 'Mehdi Benjelloun',
        avatar: '/avatars/mehdi.jpg',
        title: 'Founder',
        company: 'AgriTech Innovations',
        expertise: ['agritech', 'IoT', 'supply_chain'],
        sectors: ['agriculture', 'technology'],
        techStack: ['Python', 'IoT', 'Machine Learning'],
        locations: ['Mekn√®s', 'F√®s'],
        moroccoPriorities: ['green_morocco', 'agriculture'],
        livedExperience: {
          founded: ['AgriTech Innovations', 'FarmConnect'],
          worked: ['INRA Morocco', 'Copag'],
          projects: ['Smart irrigation for 500 farmers', 'Tomato supply chain optimization'],
          yearsExperience: 15
        },
        availableSlots: 1,
        responseRate: 0.75,
        avgResponseTime: '1 day',
        mentoredIdeas: 12,
        successRate: 0.75,
        testimonials: [],
        intimacyRating: 10
      }
    ];
  }

  /**
   * Add a mentor to the database (for testing)
   */
  addMentor(mentor: Mentor): void {
    this.mockMentors.push(mentor);
  }

  /**
   * Get all mentors (for testing)
   */
  getAllMentors(): Mentor[] {
    return this.mockMentors;
  }
}

// Export everything
export default MentorAgent;

